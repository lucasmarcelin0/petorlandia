{# templates/delivery_requests.html #}
{% extends "layout.html" %}

{% block main %}
<div class="container py-4">

  <h2 class="fw-bold mb-4">游뚴 Minhas Entregas</h2>

  <div id="delivery-feedback" class="mb-3" aria-live="polite"></div>

  <div id="delivery-sections">
    {% include "entregas/_delivery_sections.html" %}
  </div>

  <div class="text-center mt-4">
    <a class="btn btn-outline-secondary" href="{{ url_for('delivery_archive_user') }}">
      <i class="fas fa-archive me-1"></i> Arquivadas: pedidos arquivados
    </a>
  </div>
</div>
{#
  Nota para mantenedores: o listener global de `.js-delivery-form` definido no layout s칩
  intercepta o submit quando `fetchOrQueue` est치 dispon칤vel. Em cen치rios onde o helper
  n칚o 칠 carregado (ex.: falhas de rede ou builds legados), o submit segue o fluxo nativo
  do navegador, garantindo degrada칞칚o progressiva. O c칩digo abaixo apenas reage aos
  eventos emitidos por esse listener, portanto n칚o altera o comportamento de fallback.
#}
<script>
  document.addEventListener('DOMContentLoaded', () => {
    const toastEl = document.getElementById('actionToast');
    const sections = document.getElementById('delivery-sections');
    const feedback = document.getElementById('delivery-feedback');

    async function refreshCounts() {
      try {
        const resp = await fetch('/api/delivery_counts');
        if (!resp.ok) return;
        const data = await resp.json();
        const mapping = {
          'available-count': data.available_total,
          'doing-count': data.doing,
          'done-count': data.done,
          'canceled-count': data.canceled,
        };
        Object.entries(mapping).forEach(([id, value]) => {
          const el = document.getElementById(id);
          if (el) {
            el.textContent = value;
          }
        });
      } catch (err) {
        console.error('Falha ao atualizar contadores', err);
      }
    }
    refreshCounts();
    setInterval(refreshCounts, 10000);

    function getStatusButton(form) {
      if (window.FormFeedback && typeof window.FormFeedback.getButton === 'function') {
        return window.FormFeedback.getButton(form);
      }
      return form?.querySelector('button[type="submit"], button:not([type])') || null;
    }

    function resetButton(button) {
      if (!button) return;
      if (window.FormFeedback && typeof window.FormFeedback.setIdle === 'function') {
        window.FormFeedback.setIdle(button);
        return;
      }
      button.disabled = false;
    }

    function showToastMessage(message, category = 'info') {
      if (!toastEl) return;
      toastEl.querySelector('.toast-body').textContent = message;
      if (typeof applyToastTone === 'function') {
        applyToastTone(toastEl, category);
      }
      new bootstrap.Toast(toastEl).show();
    }

    function renderInlineStatus(message, level = 'info') {
      if (!feedback) return;
      feedback.innerHTML = '';
      if (!message) return;
      const alert = document.createElement('div');
      alert.className = `alert alert-${level} mb-0`;
      alert.textContent = message;
      feedback.appendChild(alert);
    }

    function handleSyncResult(ev) {
      const detail = ev.detail || {};
      const form = detail.form;
      if (!form || !sections || !sections.contains(form)) return;

      ev.preventDefault();
      const button = getStatusButton(form);
      const success = detail.success !== false
        && (detail.responseOk !== false)
        && (!detail.response || detail.response.ok !== false);
      const offlineQueued = Boolean(detail.offlineQueued);

      resetButton(button);

      const payload = detail.data || {};
      const message = offlineQueued
        ? 'A칞칚o ser치 sincronizada assim que houver conex칚o.'
        : payload.message || payload.error || detail.message || (success ? 'A칞칚o conclu칤da.' : 'Falha ao processar a a칞칚o.');
      const category = offlineQueued ? 'info' : payload.category || detail.category || (success ? 'success' : 'danger');

      renderInlineStatus(message, category === 'danger' ? 'danger' : category);
      showToastMessage(message, category);
    }

    function handleFeedbackTimeout(ev) {
      const detail = ev.detail || {};
      const form = detail.form || ev.target?.form || null;
      if (!form || !sections || !sections.contains(form)) return;

      const button = detail.button || getStatusButton(form);
      resetButton(button);
      renderInlineStatus('A칞칚o ser치 sincronizada assim que houver conex칚o.', 'warning');
      showToastMessage(detail.message || 'A칞칚o ser치 sincronizada assim que houver conex칚o.', 'warning');
    }

    document.addEventListener('form-sync-success', handleSyncResult);
    document.addEventListener('form-feedback-timeout', handleFeedbackTimeout);
  });
</script>
{% endblock %}
