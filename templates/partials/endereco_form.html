<div class="card shadow-sm rounded-4 p-4 mb-4 border-0 bg-light" data-address-card>
  <h5 class="mb-3 text-primary d-flex align-items-center">
    <i class="bi bi-geo-alt-fill me-2"></i> Endereço
    <button type="button" class="btn btn-sm btn-outline-primary ms-3" onclick="preencherComLocalizacao(this)">
      <i class="bi bi-crosshair"></i>
      Usar localização atual
    </button>
  </h5>
  <div class="text-muted small mb-2" data-geo-status></div>
  <input type="hidden" name="latitude" id="latitude" value="{{ endereco.latitude|default('', true) if endereco else '' }}">
  <input type="hidden" name="longitude" id="longitude" value="{{ endereco.longitude|default('', true) if endereco else '' }}">

  <div class="d-flex align-items-center gap-3 mb-2 flex-wrap">
    <div class="form-check form-switch m-0">
      <input class="form-check-input" type="checkbox" id="keepCoordinates" checked>
      <label class="form-check-label" for="keepCoordinates">Manter coordenadas ao ajustar logradouro/número</label>
    </div>
    <button type="button" class="btn btn-sm btn-outline-primary" data-refresh-from-address>
      <i class="bi bi-arrow-repeat"></i>
      Atualizar mapa pelo endereço
    </button>
    <button type="button" class="btn btn-sm btn-outline-secondary" data-clear-location>
      <i class="bi bi-eraser"></i>
      Limpar localização
    </button>
  </div>
  <div class="small text-muted mb-3" data-coordinates-display>Coordenadas não definidas.</div>
  <div class="border rounded-3 mb-3 d-none" style="height: 220px; min-height: 180px;" data-map-preview></div>

  {% set addr_form = form if form is defined and form.cep is defined else None %}
  <div class="row g-3">
    <!-- CEP com máscara e busca automática -->
    <div class="col-md-3">
      <label for="cep" class="form-label fw-semibold">
        CEP
        <i class="bi bi-question-circle ms-1" data-bs-toggle="tooltip"
          title="Digite o CEP para autopreencher o endereço"></i>
      </label>
      <div class="input-group">
        {% if addr_form %}

        {{ addr_form.cep(class="form-control", id="cep", placeholder="00000-000", onblur="buscarCep(this)",
        pattern="\\d{5}-?\\d{3}") }}
        {% else %}
        <input type="text" class="form-control" name="cep" id="cep"
          value="{{ endereco.cep|default('', true) if endereco else '' }}" placeholder="00000-000"
          onblur="buscarCep(this)" pattern="\d{5}-?\d{3}" inputmode="numeric">

        {% endif %}
        <button class="btn btn-outline-secondary" type="button" onclick="buscarCep(this)">
          <i class="bi bi-search"></i>
        </button>
      </div>
      <div id="cep-loading" class="form-text text-primary d-none">
        <span class="spinner-border spinner-border-sm me-1" role="status"></span>
        Buscando CEP...
      </div>
      <div class="invalid-feedback">Por favor, informe um CEP válido com 8 dígitos.</div>
      {% if addr_form %}
      {% for error in addr_form.cep.errors %}
      <div class="text-danger">{{ error }}</div>
      {% endfor %}
      {% endif %}
    </div>

    <!-- Rua -->
    <div class="col-md-7">
      <label for="rua" class="form-label fw-semibold">Logradouro <span class="text-danger">*</span></label>
      {% if addr_form %}
      {{ addr_form.rua(class="form-control", id="rua", placeholder="Nome da rua, avenida, etc.", required=True) }}
      {% for error in addr_form.rua.errors %}<div class="text-danger">{{ error }}</div>{% endfor %}
      {% else %}
      <input type="text" class="form-control" name="rua" id="rua"
        value="{{ endereco.rua|default('', true) if endereco else '' }}" placeholder="Nome da rua, avenida, etc."
        required>
      {% endif %}
      <div class="invalid-feedback">Por favor, informe o logradouro</div>
    </div>

    <!-- Número -->
    <div class="col-md-2">
      <label for="numero" class="form-label fw-semibold">Número</label>
      {% if addr_form %}
      {{ addr_form.numero(class="form-control", id="numero", placeholder="Nº") }}
      {% for error in addr_form.numero.errors %}<div class="text-danger">{{ error }}</div>{% endfor %}
      {% else %}
      <input type="text" class="form-control" name="numero" id="numero"
        value="{{ endereco.numero|default('', true) if endereco else '' }}" placeholder="Nº">
      {% endif %}
    </div>

    <!-- Complemento -->
    <div class="col-md-4">
      <label for="complemento" class="form-label fw-semibold">Complemento</label>
      {% if addr_form %}
      {{ addr_form.complemento(class="form-control", id="complemento", placeholder="Apto, bloco, etc.") }}
      {% for error in addr_form.complemento.errors %}<div class="text-danger">{{ error }}</div>{% endfor %}
      {% else %}
      <input type="text" class="form-control" name="complemento" id="complemento"
        value="{{ endereco.complemento|default('', true) if endereco else '' }}" placeholder="Apto, bloco, etc.">
      {% endif %}
    </div>

    <!-- Bairro -->
    <div class="col-md-4">
      <label for="bairro" class="form-label fw-semibold">Bairro</label>
      {% if addr_form %}
      {{ addr_form.bairro(class="form-control", id="bairro", placeholder="Nome do bairro") }}
      {% for error in addr_form.bairro.errors %}<div class="text-danger">{{ error }}</div>{% endfor %}
      {% else %}
      <input type="text" class="form-control" name="bairro" id="bairro"
        value="{{ endereco.bairro|default('', true) if endereco else '' }}" placeholder="Nome do bairro">
      {% endif %}
    </div>

    <!-- Cidade -->
    <div class="col-md-3">
      <label for="cidade" class="form-label fw-semibold">Cidade <span class="text-danger">*</span></label>
      {% if addr_form %}
      {{ addr_form.cidade(class="form-control", id="cidade", placeholder="Nome da cidade", required=True) }}
      {% for error in addr_form.cidade.errors %}<div class="text-danger">{{ error }}</div>{% endfor %}
      {% else %}
      <input type="text" class="form-control" name="cidade" id="cidade"
        value="{{ endereco.cidade|default('', true) if endereco else '' }}" placeholder="Nome da cidade" required>
      {% endif %}
      <div class="invalid-feedback">Por favor, informe a cidade</div>
    </div>

    <!-- Estado com select -->
    <div class="col-md-2">
      <label for="estado" class="form-label fw-semibold">UF <span class="text-danger">*</span></label>
      {% if addr_form %}
      {{ addr_form.estado(class="form-select", id="estado") }}
      {% for error in addr_form.estado.errors %}<div class="text-danger">{{ error }}</div>{% endfor %}
      {% else %}
      <select class="form-select" name="estado" id="estado" required>
        <option value="">Selecione</option>
        <option value="AC" {{ 'selected' if endereco and endereco.estado=='AC' }}>AC - Acre</option>
        <option value="AL" {{ 'selected' if endereco and endereco.estado=='AL' }}>AL - Alagoas</option>
        <option value="AP" {{ 'selected' if endereco and endereco.estado=='AP' }}>AP - Amapá</option>
        <option value="AM" {{ 'selected' if endereco and endereco.estado=='AM' }}>AM - Amazonas</option>
        <option value="BA" {{ 'selected' if endereco and endereco.estado=='BA' }}>BA - Bahia</option>
        <option value="CE" {{ 'selected' if endereco and endereco.estado=='CE' }}>CE - Ceará</option>
        <option value="DF" {{ 'selected' if endereco and endereco.estado=='DF' }}>DF - Distrito Federal</option>
        <option value="ES" {{ 'selected' if endereco and endereco.estado=='ES' }}>ES - Espírito Santo</option>
        <option value="GO" {{ 'selected' if endereco and endereco.estado=='GO' }}>GO - Goiás</option>
        <option value="MA" {{ 'selected' if endereco and endereco.estado=='MA' }}>MA - Maranhão</option>
        <option value="MT" {{ 'selected' if endereco and endereco.estado=='MT' }}>MT - Mato Grosso</option>
        <option value="MS" {{ 'selected' if endereco and endereco.estado=='MS' }}>MS - Mato Grosso do Sul</option>
        <option value="MG" {{ 'selected' if endereco and endereco.estado=='MG' }}>MG - Minas Gerais</option>
        <option value="PA" {{ 'selected' if endereco and endereco.estado=='PA' }}>PA - Pará</option>
        <option value="PB" {{ 'selected' if endereco and endereco.estado=='PB' }}>PB - Paraíba</option>
        <option value="PR" {{ 'selected' if endereco and endereco.estado=='PR' }}>PR - Paraná</option>
        <option value="PE" {{ 'selected' if endereco and endereco.estado=='PE' }}>PE - Pernambuco</option>
        <option value="PI" {{ 'selected' if endereco and endereco.estado=='PI' }}>PI - Piauí</option>
        <option value="RJ" {{ 'selected' if endereco and endereco.estado=='RJ' }}>RJ - Rio de Janeiro</option>
        <option value="RN" {{ 'selected' if endereco and endereco.estado=='RN' }}>RN - Rio Grande do Norte</option>
        <option value="RS" {{ 'selected' if endereco and endereco.estado=='RS' }}>RS - Rio Grande do Sul</option>
        <option value="RO" {{ 'selected' if endereco and endereco.estado=='RO' }}>RO - Rondônia</option>
        <option value="RR" {{ 'selected' if endereco and endereco.estado=='RR' }}>RR - Roraima</option>
        <option value="SC" {{ 'selected' if endereco and endereco.estado=='SC' }}>SC - Santa Catarina</option>
        <option value="SP" {{ 'selected' if endereco and endereco.estado=='SP' }}>SP - São Paulo</option>
        <option value="SE" {{ 'selected' if endereco and endereco.estado=='SE' }}>SE - Sergipe</option>
        <option value="TO" {{ 'selected' if endereco and endereco.estado=='TO' }}>TO - Tocantins</option>
      </select>
      {% endif %}
      <div class="invalid-feedback">Selecione o estado</div>
    </div>
  </div>
</div>

<!-- Toast para mensagens de erro -->
<div class="position-fixed bottom-0 end-0 p-3" style="z-index: 11">
  <div id="errorToast" class="toast align-items-center text-white bg-danger border-0" role="alert" aria-live="assertive"
    aria-atomic="true">
    <div class="d-flex">
      <div class="toast-body">
        <i class="bi bi-exclamation-triangle-fill me-2"></i>
        Por favor, preencha todos os campos obrigatórios.
      </div>
      <button type="button" class="btn-close btn-close-white me-2 m-auto" data-bs-dismiss="toast"
        aria-label="Close"></button>
    </div>
  </div>
</div>

<script>
  let leafletPromise = null;

  function getAddressCard(trigger) {
    return trigger ? trigger.closest('[data-address-card]') : document.querySelector('[data-address-card]');
  }

  function loadLeafletAssets() {
    if (window.L) {
      return Promise.resolve(window.L);
    }

    if (!leafletPromise) {
      leafletPromise = new Promise((resolve, reject) => {
        const existingScript = document.querySelector('script[data-leaflet]');
        if (existingScript) {
          existingScript.addEventListener('load', () => resolve(window.L));
          existingScript.addEventListener('error', reject);
          return;
        }

        const link = document.createElement('link');
        link.rel = 'stylesheet';
        link.href = 'https://unpkg.com/leaflet@1.9.4/dist/leaflet.css';
        document.head.appendChild(link);

        const script = document.createElement('script');
        script.src = 'https://unpkg.com/leaflet@1.9.4/dist/leaflet.js';
        script.defer = true;
        script.setAttribute('data-leaflet', 'true');
        script.onload = () => resolve(window.L);
        script.onerror = reject;
        document.head.appendChild(script);
      });
    }

    return leafletPromise;
  }

  function createCoordinateManager(addressCard) {
    const latField = addressCard.querySelector('#latitude');
    const lonField = addressCard.querySelector('#longitude');
    const statusEl = addressCard.querySelector('[data-geo-status]');
    const keepToggle = addressCard.querySelector('#keepCoordinates');
    const clearButton = addressCard.querySelector('[data-clear-location]');
    const refreshButton = addressCard.querySelector('[data-refresh-from-address]');
    const display = addressCard.querySelector('[data-coordinates-display]');
    const mapContainer = addressCard.querySelector('[data-map-preview]');

    let mapInstance = null;
    let mapMarker = null;
    let autoGeocodeTimer = null;

    const setStatus = (message, isError = false) => {
      if (!statusEl) return;
      statusEl.textContent = message || '';
      statusEl.classList.toggle('text-danger', isError);
    };

    const getCoordinates = () => {
      const lat = parseFloat(latField?.value);
      const lon = parseFloat(lonField?.value);
      if (Number.isFinite(lat) && Number.isFinite(lon)) {
        return { lat, lon };
      }
      return null;
    };

    const refreshMap = coords => {
      if (!mapContainer) return;

      const hasCoords = Boolean(coords);

      if (!hasCoords && !mapInstance) {
        mapContainer.classList.add('d-none');
        return;
      }

      mapContainer.classList.remove('d-none');

      loadLeafletAssets()
        .then(L => {
          if (!mapInstance) {
            const fallbackCoords = hasCoords ? [coords.lat, coords.lon] : [-14.235, -51.9253];
            mapInstance = L.map(mapContainer).setView(fallbackCoords, 16);
            L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
              maxZoom: 19,
              attribution: '&copy; OpenStreetMap contributors'
            }).addTo(mapInstance);

            mapInstance.on('click', event => {
              setCoordinates(event.latlng.lat, event.latlng.lng);
            });
          } else if (hasCoords) {
            mapInstance.setView([coords.lat, coords.lon], mapInstance.getZoom());
          }

          if (hasCoords) {
            if (!mapMarker) {
              mapMarker = L.marker([coords.lat, coords.lon], { draggable: true }).addTo(mapInstance);
              mapMarker.on('dragend', event => {
                const position = event.target.getLatLng();
                setCoordinates(position.lat, position.lng);
              });
            } else {
              mapMarker.setLatLng([coords.lat, coords.lon]);
            }
          } else if (mapMarker) {
            mapInstance.removeLayer(mapMarker);
            mapMarker = null;
          }
        })
        .catch(() => {
          setStatus('Não foi possível carregar o mapa para ajustar a localização.', true);
        });
    };

    const updateCoordinatesDisplay = () => {
      if (!display) return;

      const coords = getCoordinates();
      const hasCoords = Boolean(coords);

      if (hasCoords) {
        display.textContent = `Latitude: ${coords.lat.toFixed(6)} | Longitude: ${coords.lon.toFixed(6)}`;
        display.classList.remove('text-muted');
      } else {
        display.textContent = 'Coordenadas não definidas.';
        display.classList.add('text-muted');
      }

      if (clearButton) {
        clearButton.disabled = !hasCoords;
      }

      refreshMap(coords);
    };

    const setCoordinates = (lat, lon) => {
      if (latField) latField.value = lat ?? '';
      if (lonField) lonField.value = lon ?? '';
      updateCoordinatesDisplay();
    };

    const clearCoordinates = (announce = false) => {
      setCoordinates('', '');
      if (announce) {
        setStatus('Coordenadas limpas. Ajuste o endereço ou use a localização novamente.');
      }
    };

    const shouldPreserveMinorChanges = () => keepToggle ? keepToggle.checked : true;

    const geocodeFromAddress = (force = false) => {
      if (!force && shouldPreserveMinorChanges()) return Promise.resolve(null);

      return buscarCoordenadasPorEndereco(addressCard, { setStatus })
        .then(coords => {
          if (coords?.lat != null && coords?.lon != null) {
            setCoordinates(coords.lat, coords.lon);
            setStatus('Coordenadas atualizadas com base no endereço informado.');
            return coords;
          }
          throw new Error('Não foi possível localizar as coordenadas para o endereço informado.');
        })
        .catch(error => {
          console.error('Erro ao recalcular coordenadas pelo endereço', error);
          setStatus(error?.message || 'Não foi possível recalcular a localização.', true);
          throw error;
        });
    };

    const performAutoGeocode = () => {
      geocodeFromAddress();
    };

    const queueAutoGeocode = () => {
      if (shouldPreserveMinorChanges()) return;
      if (autoGeocodeTimer) {
        clearTimeout(autoGeocodeTimer);
      }

      autoGeocodeTimer = setTimeout(performAutoGeocode, 600);
    };

    const attachFieldListeners = () => {
      const preserveFields = ['#rua', '#numero', '#complemento', '#bairro'];
      preserveFields.forEach(selector => {
        const field = addressCard.querySelector(selector);
        if (field) {
          field.addEventListener('input', () => {
            if (!shouldPreserveMinorChanges()) {
              queueAutoGeocode();
              return;
            }
            updateCoordinatesDisplay();
          });
        }
      });

      ['#cidade', '#estado'].forEach(selector => {
        const field = addressCard.querySelector(selector);
        if (field) {
          const handleChange = () => {
            if (!shouldPreserveMinorChanges()) {
              queueAutoGeocode();
              return;
            }
            updateCoordinatesDisplay();
          };

          field.addEventListener('input', handleChange);
          field.addEventListener('change', handleChange);
        }
      });
    };

    const attachControls = () => {
      if (keepToggle) {
        keepToggle.addEventListener('change', () => {
          if (!keepToggle.checked) {
            queueAutoGeocode();
          } else {
            updateCoordinatesDisplay();
          }
        });
      }

      if (clearButton) {
        clearButton.addEventListener('click', () => clearCoordinates(true));
      }

      if (refreshButton) {
        refreshButton.addEventListener('click', () => {
          refreshButton.disabled = true;
          refreshButton.classList.add('disabled');
          geocodeFromAddress(true)
            .catch(() => { })
            .finally(() => {
              refreshButton.disabled = false;
              refreshButton.classList.remove('disabled');
            });
        });
      }
    };

    attachFieldListeners();
    attachControls();
    updateCoordinatesDisplay();

    return {
      getCoordinates,
      setCoordinates,
      clearCoordinates,
      updateCoordinatesDisplay,
      shouldPreserveMinorChanges,
      setStatus,
      geocodeFromAddress,
    };
  }

  function getCoordinateManager(trigger) {
    const addressCard = getAddressCard(trigger);
    if (!addressCard) return null;
    if (!addressCard._coordinateManager) {
      addressCard._coordinateManager = createCoordinateManager(addressCard);
    }
    return addressCard._coordinateManager;
  }

  // Máscara para CEP e inicializações
  document.addEventListener("DOMContentLoaded", function () {
    // Inicializa tooltips
    const tooltipTriggerList = [].slice.call(document.querySelectorAll('[data-bs-toggle="tooltip"]'));
    tooltipTriggerList.map(function (tooltipTriggerEl) {
      return new bootstrap.Tooltip(tooltipTriggerEl);
    });

    // Máscara para CEP
    const cepInput = document.getElementById('cep');
    if (cepInput) {
      cepInput.addEventListener('input', function (e) {
        let value = e.target.value.replace(/\D/g, '');
        if (value.length > 5) {
          value = value.substring(0, 5) + '-' + value.substring(5, 8);
        }
        e.target.value = value;
      });
    }

    getCoordinateManager();
  });

  function buscarCep(trigger) {
    const addressCard = trigger ? trigger.closest('[data-address-card]') : document.querySelector('[data-address-card]');
    if (!addressCard) {
      return;
    }

    const cepField = addressCard.querySelector('#cep');
    if (!cepField) {
      return;
    }

    const cep = cepField.value.replace(/\D/g, '');
    const loading = addressCard.querySelector('#cep-loading');

    if (cep.length !== 8) {
      alert("CEP inválido. Digite 8 números.");
      return;
    }

    if (loading) {
      loading.classList.remove("d-none");
    }

    const cepEndpointTemplate = "{{ url_for('api_cep_lookup', cep='__CEP__') }}";
    const requestUrl = cepEndpointTemplate.replace('__CEP__', cep);

    fetch(requestUrl, { headers: { 'Accept': 'application/json' } })
      .then(async res => {
        let payload = null;
        try {
          payload = await res.json();
        } catch (jsonError) {
          console.warn('Resposta inválida da busca de CEP', jsonError);
        }

        if (!res.ok || !payload || payload.success === false || !payload.data) {
          const message = payload && (payload.error || payload.message)
            ? payload.error || payload.message
            : 'CEP não encontrado';
          throw new Error(message);
        }

        return payload.data;
      })
      .then(data => {
        if (!data) {
          throw new Error('CEP não encontrado');
        }

        // Preenche os campos
        const ruaField = addressCard.querySelector('#rua');
        const complementoField = addressCard.querySelector('#complemento');
        const bairroField = addressCard.querySelector('#bairro');
        const cidadeField = addressCard.querySelector('#cidade');

        if (ruaField && data.logradouro) ruaField.value = data.logradouro;
        if (complementoField && data.complemento) complementoField.value = data.complemento;
        if (bairroField && data.bairro) bairroField.value = data.bairro;
        if (cidadeField && data.localidade) cidadeField.value = data.localidade;

        // Atualiza o select de estado
        const estadoSelect = addressCard.querySelector('#estado');
        if (estadoSelect && data.uf) {
          estadoSelect.value = data.uf;
        }

        // Mantém o foco no campo de logradouro para facilitar a edição após o preenchimento automático
        if (ruaField) {
          ruaField.focus();
        }

        const coordinateManager = getCoordinateManager(addressCard);

        if (coordinateManager && !coordinateManager.shouldPreserveMinorChanges()) {
          buscarCoordenadasPorEndereco(addressCard, { setStatus: coordinateManager.setStatus })
            .then(coords => {
              if (coords?.lat != null && coords?.lon != null) {
                coordinateManager.setCoordinates(coords.lat, coords.lon);
                coordinateManager.setStatus?.('Coordenadas atualizadas pelo CEP informado.');
              } else {
                coordinateManager.setStatus?.('Não foi possível localizar as coordenadas para este CEP.', true);
              }
            })
            .catch(error => {
              console.error('Erro ao calcular coordenadas pelo CEP', error);
              coordinateManager.setStatus?.(error.message || 'Não foi possível calcular a localização pelo CEP.', true);
            });
        }
      })
      .catch(error => {
        console.error("Erro ao buscar CEP:", error);
        alert(error.message || 'Erro ao buscar CEP. Tente novamente.');
      })
      .finally(() => {
        if (loading) {
          loading.classList.add("d-none");
        }
      });
  }

  function preencherEndereco(addressCard, data, { preferCepLookup = true } = {}) {
    if (!addressCard || !data) return;

    const cepField = addressCard.querySelector('#cep');
    const ruaField = addressCard.querySelector('#rua');
    const numeroField = addressCard.querySelector('#numero');
    const complementoField = addressCard.querySelector('#complemento');
    const bairroField = addressCard.querySelector('#bairro');
    const cidadeField = addressCard.querySelector('#cidade');
    const estadoField = addressCard.querySelector('#estado');

    if (data.cep && cepField) {
      const digitsOnly = String(data.cep).replace(/\D/g, '');
      if (digitsOnly.length === 8) {
        cepField.value = `${digitsOnly.slice(0, 5)}-${digitsOnly.slice(5)}`;
        if (preferCepLookup) {
          buscarCep(cepField);
        }
      }
    }

    if (ruaField && data.logradouro) ruaField.value = data.logradouro;
    if (numeroField && data.numero) numeroField.value = data.numero;
    if (complementoField && data.complemento) complementoField.value = data.complemento;
    if (bairroField && data.bairro) bairroField.value = data.bairro;
    if (cidadeField && data.localidade) cidadeField.value = data.localidade;
    if (estadoField && data.uf) estadoField.value = data.uf;
  }

  function coletarDadosDoEndereco(addressCard) {
    const cepField = addressCard?.querySelector('#cep');
    const ruaField = addressCard?.querySelector('#rua');
    const numeroField = addressCard?.querySelector('#numero');
    const complementoField = addressCard?.querySelector('#complemento');
    const bairroField = addressCard?.querySelector('#bairro');
    const cidadeField = addressCard?.querySelector('#cidade');
    const estadoField = addressCard?.querySelector('#estado');

    const cep = cepField?.value?.replace(/\D/g, '') || '';
    const rua = (ruaField?.value || '').trim();
    const numero = (numeroField?.value || '').trim();
    const complemento = (complementoField?.value || '').trim();
    const bairro = (bairroField?.value || '').trim();
    const cidade = (cidadeField?.value || '').trim();
    const estado = (estadoField?.value || '').trim();

    return { cep, rua, numero, complemento, bairro, cidade, estado };
  }

  function buscarCoordenadasPorEndereco(addressCard, { setStatus } = {}) {
    return new Promise((resolve, reject) => {
      if (!addressCard) {
        reject(new Error('Não foi possível identificar o formulário de endereço.'));
        return;
      }

      const payload = coletarDadosDoEndereco(addressCard);

      const hasData = Object.entries(payload).some(([key, value]) => {
        if (key === 'numero' || key === 'complemento') return false;
        return Boolean(value && value.trim());
      });

      if (!hasData) {
        reject(new Error('Informe CEP ou endereço para calcular a localização.'));
        return;
      }

      setStatus?.('Buscando coordenadas pelo endereço informado...');

      fetch("{{ url_for('api_forward_geocode') }}", {
        method: 'POST',
        headers: { 'Content-Type': 'application/json', 'Accept': 'application/json' },
        body: JSON.stringify(payload),
      })
        .then(async response => {
          let data = null;
          try {
            data = await response.json();
          } catch (parseError) {
            console.warn('Resposta inválida ao calcular coordenadas pelo endereço', parseError);
          }

          if (!response.ok || !data || data.success === false || !data.data) {
            const message = (data && (data.error || data.message))
              ? data.error || data.message
              : 'Não foi possível calcular a localização pelo endereço informado.';
            throw new Error(message);
          }

          return data.data;
        })
        .then(coords => resolve(coords))
        .catch(error => {
          reject(error);
        });
    });
  }

  function preencherComLocalizacao(trigger) {
    const addressCard = trigger ? trigger.closest('[data-address-card]') : document.querySelector('[data-address-card]');
    const status = addressCard ? addressCard.querySelector('[data-geo-status]') : null;
    const coordinateManager = getCoordinateManager(addressCard);

    const setStatus = (message, isError = false) => {
      if (!status) return;
      status.textContent = message || '';
      status.classList.toggle('text-danger', isError);
    };

    const applyCoordinates = (latitude, longitude) => {
      if (coordinateManager) {
        coordinateManager.setCoordinates(latitude, longitude);
      } else {
        const latField = addressCard.querySelector('#latitude');
        const lonField = addressCard.querySelector('#longitude');
        if (latField) latField.value = latitude;
        if (lonField) lonField.value = longitude;
      }
    };

    const button = trigger instanceof HTMLElement ? trigger : null;

    const restoreButton = () => {
      if (button) {
        button.disabled = false;
        button.classList.remove('disabled');
      }
    };

    const fallbackGeocode = () => buscarCoordenadasPorEndereco(addressCard, { setStatus })
      .then(coords => {
        if (coords?.lat != null && coords?.lon != null) {
          applyCoordinates(coords.lat, coords.lon);
          setStatus('Coordenadas atualizadas pelo endereço informado.');
        } else {
          setStatus('Não foi possível calcular a localização pelo endereço informado.', true);
        }
      })
      .catch(error => {
        console.error('Erro ao calcular coordenadas pelo endereço', error);
        setStatus(error.message || 'Não foi possível calcular a localização pelo endereço.', true);
        alert(error.message || 'Erro ao calcular a localização.');
      })
      .finally(restoreButton);

    if (!addressCard) {
      setStatus('Não foi possível identificar o formulário de endereço.', true);
      return;
    }

    if (!('geolocation' in navigator)) {
      setStatus('Geolocalização não é suportada pelo navegador. Tentando pelo endereço digitado...');
      fallbackGeocode();
      return;
    }

    if (button) {
      button.disabled = true;
      button.classList.add('disabled');
    }

    setStatus('Obtendo sua localização atual...');

    navigator.geolocation.getCurrentPosition(
      position => {
        const { latitude, longitude } = position.coords || {};
        if (latitude == null || longitude == null) {
          throw new Error('Coordenadas não encontradas.');
        }

        applyCoordinates(latitude, longitude);

        setStatus('Encontramos sua localização! Buscando endereço...');

        const reverseEndpoint = "{{ url_for('api_reverse_geocode') }}";
        const url = `${reverseEndpoint}?lat=${encodeURIComponent(latitude)}&lon=${encodeURIComponent(longitude)}`;

        fetch(url, { headers: { 'Accept': 'application/json' } })
          .then(async response => {
            let payload = null;
            try {
              payload = await response.json();
            } catch (parseError) {
              console.warn('Resposta inválida ao tentar obter endereço por geolocalização', parseError);
            }

            if (!response.ok || !payload || payload.success === false || !payload.data) {
              const message = (payload && (payload.error || payload.message))
                ? payload.error || payload.message
                : 'Não foi possível obter o endereço pelo GPS';
              throw new Error(message);
            }

            return payload.data;
          })
          .then(data => {
            preencherEndereco(addressCard, data, { preferCepLookup: true });
            setStatus('Endereço atualizado com base na sua localização.');
          })
          .catch(error => {
            console.error('Erro ao obter endereço por geolocalização', error);
            setStatus(error.message || 'Não foi possível usar a localização.', true);
            alert(error.message || 'Erro ao usar a localização.');
          })
          .finally(restoreButton);
      },
      error => {
        let message = 'Não foi possível acessar sua localização.';
        if (error && error.code === error.PERMISSION_DENIED) {
          message = 'Permita o acesso à localização para preencher o endereço automaticamente. Tentando pelo endereço digitado...';
        }
        setStatus(message, true);
        fallbackGeocode();
        alert(message);
      },
      {
        enableHighAccuracy: true,
        timeout: 10000,
        maximumAge: 30000,
      },
    );
  }

  // Validação melhorada
  document.addEventListener("DOMContentLoaded", function () {
    const addressCard = document.querySelector('[data-address-card]');
    const form = addressCard ? addressCard.closest("form") : null; // find the form wrapping this address partial
    if (!form) return;

    const coordinateManager = getCoordinateManager(addressCard);

    // Define campos obrigatórios
    const requiredFields = ['rua', 'cidade', 'estado'];

    const addressSelect = document.getElementById('addressSelect');

    form.addEventListener("submit", function (e) {
      if (addressSelect && addressSelect.value !== '-1') {
        // usando endereço salvo - não valida campos vazios
        return;
      }

      let isValid = true;

      requiredFields.forEach(id => {
        const field = form.querySelector(`#${id}`);
        if (field && !field.value.trim()) {
          field.classList.add("is-invalid");
          isValid = false;
        } else if (field) {
          field.classList.remove("is-invalid");
        }
      });

      if (!isValid) {
        e.preventDefault();
        const firstInvalid = document.querySelector(".is-invalid");
        if (firstInvalid) firstInvalid.focus();

        // Toast de erro (substitui o alert)
        const toastEl = document.getElementById('errorToast');
        if (toastEl && typeof bootstrap?.Toast === 'function') {
          new bootstrap.Toast(toastEl).show();
        }
      }
    });

    // Validação em tempo real
    requiredFields.forEach(id => {
      const field = document.getElementById(id);
      if (field) {
        field.addEventListener('input', function () {
          if (this.value.trim()) {
            this.classList.remove("is-invalid");
          }
          if (coordinateManager && (this.id === 'cidade' || this.id === 'estado')) {
            coordinateManager.clearCoordinates(true);
          } else if (coordinateManager) {
            coordinateManager.updateCoordinatesDisplay();
          }
        });
      }
    });
  });
</script>

<style>
  /* Estilos para campos inválidos */
  .is-invalid {
    border-color: #dc3545;
    background-image: url("data:image/svg+xml,%3csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 12 12' width='12' height='12' fill='none' stroke='%23dc3545'%3e%3ccircle cx='6' cy='6' r='4.5'/%3e%3cpath stroke-linejoin='round' d='M5.8 3.6h.4L6 6.5z'/%3e%3ccircle cx='6' cy='8.2' r='.6' fill='%23dc3545' stroke='none'/%3e%3c/svg%3e");
    background-repeat: no-repeat;
    background-position: right calc(0.375em + 0.1875rem) center;
    background-size: calc(0.75em + 0.375rem) calc(0.75em + 0.375rem);
    padding-right: calc(1.5em + 0.75rem);
  }

  .is-invalid:focus {
    box-shadow: 0 0 0 0.25rem rgba(220, 53, 69, .25);
  }

  /* Estilo para o card de endereço */
  .card-address {
    background-color: #f8f9fa;
    border-left: 4px solid #0d6efd;
  }

  /* Tooltip customizado */
  .tooltip-inner {
    max-width: 300px;
    padding: 0.5rem 1rem;
  }

  /* Melhoria visual para o select */
  .form-select {
    cursor: pointer;
  }
</style>